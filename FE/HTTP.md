

## http

### https 与 http 的区别

- `http` 采用明文传输，`https` 是密文传输
- `https` 在 `http` 基础上增加了一层会话层协议(`SSL` 或 `TSL`)
- 协议不同，端口不同。`http` 默认端口 `80`，`https` 默认端口为 `443`

`https` 如何加密过程:

0. 客户端与服务端采用非对称加密各自生成自己的公钥和私钥
1. 客户端与服务端互换公钥
2. 客户端与服务端通过对方的公钥加密信息并发送，双方收到后以各自的私钥解密，从而保证通信

上述的流程存在两个问题:

1. 加密方式为非对称加密，算法相对复杂，每次加密&解密所耗费的时间过长
2. 存在中间人攻击。中间人自己生成一对公钥&私钥，在首次客户端与服务端交换公钥的过程中，将双方的公钥统一替换成自己的公钥。客户端与服务端在不知情的情况下，会用中间人的公钥来加密信息，这些信息中间人都可以通过自身的私钥来解密进而窃取与篡改。

解决方案:

1. 信息的加密方式改为对称加密
2. 引入 CA 权威机构来验证合法性。
   1. 服务端将自身公钥和申请信息发送给 CA 申请证书，CA 机构确认申请人的合法性无误后返回证书（证书由服务端申请信息和服务端公钥加密而来）以及 CA 的公钥。
   2. 服务端将证书和 CA 公钥发送给客户端，客户端通过本地（浏览器和操作系统会维护权威的CA机构）维护的 CA 信息验证证书合法性，验证无误后通过本地维护的 CA 私钥将证书解密，验证其他信息 & 拿到服务器公钥。客户端通过服务端公钥将用于“对称加密的密钥“进行加密，服务端收到后用自身私钥解密拿到“对称加密的密钥”，后续客户端和服务端通过这个“对称加密的密钥”进行加密通信。

### HTTPS 流程

1. 客户端向服务端发送第一次请求，并携带信息：支持的 `TSL` 协议版本、支持的对称加密算法、随机数 A
2. 服务端接收到请求后，会根据客户端传递的信息，协商出最终的 `TSL` 协议版本和对称加密算法，并将这些信息与随机数 B 和 CA 证书一起返回
3. 客户端收到服务端返回的证书、协商结果、随机数 B
   1. 根据浏览器/系统内置的 CA 机构公钥校验该证书合法性
      1. 根据证书链逐级校验合法性
      2. 通过本地存储的 CA 机构的公钥将证书加密过后的签名解密，拿到签名 hash，然后根据同样的签名摘要算法，将证书明文部分进行签名，并将自己生成的签名与上述解密开来的签名 `hash` 进行比较，保证信息没被篡改
      3. 根据证书内的域名和证书有效期判断证书是否可信任
   2. 证书无误后，拿到证书里存放着的服务器公钥，通过该公钥加随机数 C 进行加密，传输给服务端。同时自身根据协商好的对称加密算法，对 随机数 A + B + C 进行加密，得到最终的“对称加密密钥”
4. 服务端收到公钥加密的随机数 C，用自己的私钥解开，并采用协商好的加密算法也将随机数 A + B + C 加密，得到与客户端一样的“对称加密的密钥”，后续通信的内容就通过该密钥加密通信。

> 服务端申请证书过程:
>
> 1. 服务端将自身机构/企业信息以及公钥发给权威 CA 机构
> 2. CA 机构通过线上/线下各种有效的手段验证该服务器的合法性
> 3. 如果确认无误后，CA 机构将证书所有者信息、CA机构信息、服务器公钥、签名所用算法、指纹以及指纹算法、证书有效期等等信息明文存放在证书里，同时根据这些明文信息进行签名生成 hash，通过自身的私钥将 hash 加密，最终返回给服务端最终的证书

### HTTP2 和 HTTP1 的优化

`HTTP1.1` 对比 `HTTP1.1` 的优化点：
- 在缓存方面，添加了 `Cache-Control`（强缓存）;`ETag`、`If-No-Match`(协商缓存)头部字段
- `HTTP1.1` 默认开启长连接 `Connection: keep-alive`，多次连接会复用 `TCP` 请求，避免每次请求都要重新进行 `TCP` 的三次握手。
- 增加管道机制(`pipeline`)，多个请求会通过一个 `TCP` 链接并发出去，不过服务端还是依次响应并返回（队头阻塞）。谷歌浏览器限制为 `6` 个并发量
- 增加 `PUT`、`DELETE`、`OPTIONS`、`TRACE`、`CONNECT` 等方法

`HTTP2` 对比 `HTTP1.1` 的优化点：
- 支持二进制的传送，`HTTP1.x` 则是字符串传送
    - 当客户端向服务端发起多个请求，这个请求会被分解为一个个数据帧，在 `TCP` 链路中无序传输，同一个请求的帧的流标识是一样的，服务端接收到数据后，会根据流标识组合成一个完整请求。
- 支持多路复用，多个请求采用同一个 `TCP` 连接，多个请求随机混杂在一起，服务端也不用遵循请求顺序，并行执行，避免原来的序列问题带来的队头阻塞
- 头部压缩：多次请求和响应头部带有大量信息，而大多数的时候都是一样的。`HTTP2.0` 里将头部维护为两份字典：一份是静态字典，包含常见头部名称与值的组合代码；一份是可动态添加内容的动态字典；客户端和服务端各自维护这两份字典；字典只有在头部有改动时才会更新。避免了重复头部的传输，减少了需要传输的大小。
     > 动态字典有大小限制，当新项被增加时，旧项会被删除
- 服务器推送：服务端可以猜测客户端的需要，主动推送资源到客户端。
    - 当浏览器请求一个页面时，服务器可以主动推送这个页面需要的 `css`、`js` 等，不需要等待浏览器解析页面


### 三次握手

三次握手：
1. 第一次：客户端发送 `SYN` 包和初始序号 `seq = x`  给服务端，此时客户端状态为 `SYN-SENT`
2. 第二次：服务端收到 `SYN` 包后，将标识位 `SYN` 和 `ACK` 置为1，确认序号 `ack = x + 1`, 初始序号 `seq = y` 发送给客户端，此时服务端状态为 `SYN-RECEIVED`
3. 第三次：客户端收到后，将标识位 `ACK` 置为1, 确认序号 `ack = y + 1`, 自己的序号 `seq = x + 1`, 发送给服务端，服务端收到后也将状态切换为 `ESTABLISHED`

- `seq`序号，用来标识从`TCP`源端向目的端发送的字节流，发起方发送数据时对此进行标记
- `ack`确认序号，只有`ACK`标志位为1时，确认序号字段才有效，`ack=seq+1`
标识位：
- `ACK`：确认标识，用于表示对数据包的成功接收。
- `SYN`：同步标识，表示 `TCP` 连接已初始化，发起一个新连接。
- `FIN`：完成标识，释放一个连接，用于拆除上一个 `SYN` 标识。一个完整的TCP连接过程一定会有 `SYN` 和 `FIN` 包。

为什么不能两次握手？
> `TCP` 的特点的可靠传输，服务端和客户端都需要可靠传输，就需要确认双方的发送和接收能力，第一次握手确认了客户端的发送能力，第二次确认了服务端的发送和接收能力，第三次确认了客户端的接收能力

两次握手，服务器不能确定客户端已经收到了确认请求，不能确认是否建立好了连接。服务器认为建立好了连接，发送数据包，结果发的包客户端没收到，那么攻击服务器就很容易了，只发包不收包。

### 四次挥手

四次挥手：
- 第一次：客户端主动关闭放发送一个 `FIN`，用来关闭客户端到服务端的数据传输，告诉服务端我不会给你发送数据了
- 第二次：服务端收到 `FIN` 包后，发送一个 `ACK` 给客户端，确认序号为收到序号 + 1
- 第三次：服务端发送完数据后，服务端发送一个 `FIN`，用来关闭服务端到客户端的数据传输，告诉客户端我不会给你发数据了
- 第四次：客户端收到 `FIN` 后，发送一个 `ACK` 给服务端，确认序号为收到序号 + 1，完成四次挥手

四次握手后，客户端还会等待 `2MSL`（MSL:最长报文段寿命，一般2min） 的时间，为了保证客户端发送的 `ACK` 报文能够到达服务器，因为这个报文可能会丢失，服务器收不到确认会超时重传 `FIN` + `ACK`
报文段，客户端能在 `2MSL` 时间内收到这个重传的报文段，然后客户端重新确认。

为什么要等待 2MSL 而不是 1MSL
- 1 个 `MSL` 保证第四次挥手的 `ACK` 可以发送到对端
- 1 个 `MSL` 保证对端的重传报文可以到达

为什么连接的时候是三次握手，关闭的时候却是四次挥手？
- 服务端接收到客户端的 `SYN` 连接请求报文后，可以直接发送 `SYN + ACK` 报文
- 但是关闭连接时，当服务端接收到 `FIN` 报文时，很可能并不会立即关闭连接，所以只能先回复一个 `ACk` 报文，告诉客户端你发的 `FIN` 报文我收到了，只有等服务端所有的报文发送完了，我才能发送 `FIN` 报文，因此不能一起发送，所以需要四次。

## 状态码

状态码用于表示服务器对请求的处理结果

- `1xx`：指示信息——表示请求已经接受，继续处理
    - `100 Continue` 一般在发送 `post` 请求时，已发送了 `http header` 之后服务端返回此信息，表示确认，之后发送具体参数信息。
- `2xx`：成功
    - `200 OK` 正常返回信息
    - `201 Created` 请求成功并且服务器创建了新的资源
    - `202 Accepted` 服务器已接受请求，但尚未处理
- `3xx`：重定向
    - `301 Moved Permanently` 永久重定向
    - `302 Found` 临时重定向
    - `303 See Other` 临时重定向，且总是使用 `GET` 请求新的 `URI`
    - `304 Not Modified` 请求内容未改动，走缓存
- `4xx`：客户端错误
    - `400 Bad Request` 服务器无法理解请求格式
    - `401 Unauthorized` 请求未授权
    - `403 Forbidden` 禁止访问
    - `404 Not Found` 找不到与 `URI` 相匹配的资源
- `5xx`：服务器错误。
    - `500 Internal Server Error` 服务器内部错误
    - `503 Service Unavailable` 服务器暂时无法处理请求

## 浏览器缓存

浏览器缓存分为两种：强缓存和协商缓存，强缓存不经过服务器，协商缓存需要向服务器发起请求，强缓存的优先级高于协商缓存。

### 强缓存

强缓存会直接从浏览器中拿数据，可以通过 `Expires` 和 `Cache-Control` 响应头实现，强缓存状态码为`200`。

`Expires`
> `Expires` 是 `HTTP/1.0` 的产物，表示资源会在 `Wed, 03 Mar 2021 15:13:48 GMT` 过期（`Expires: Wed, 03 Mar 2021 15:13:48 GMT`）,使用的是绝对时间，如果服务端和客户端的时间产生偏差，那么会导致命中的缓存产生偏差

`Cache-Control`
> `Cache-Control` 出现于 `HTTP/1.1` ，优先级高于 `Expires`，表示资源会在 `30`（`Cache-control: max-age=30`） 秒后过期

`Cache-control`有很多属性：
`private`：客户端可以缓存
`public`：客户端和代理服务器都可以缓存
`max-age=t`：缓存内容将在 `t` 秒后失效
`no-cache`：需要使用协商缓存来验证缓存数据
`no-store`：所有内容都不会缓存


### 协商缓存

强缓存失效后，浏览器会携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存。

`Last-Modified` 和 `If-Modified-Since`：
> `Last_Modified` 表示请求的资源的最后修改时间，`If-Modified-Since` 会将 `Last-Modified` 的值发送给服务器，与被请求资源的最后修改时间对比，如果资源更新了就会将新的资源发送回来，否则返回 `304` 状态码，代表资源无更新，继续使用缓存文件。

`Last-Modified` 弊端：
1. 如果文件只是被打开，没有修改，也会造成 `Last-Modified` 修改，服务器不能命中缓存。
2. 只能以秒计时，如果在毫秒级的时间内修改了文件，服务器 `Last-Modified` 的值并不会修改，会返回`304`，浏览器就会是自己的缓存 。

`ETag` 和 `If-None-Match`
> `ETag` 是文件指纹，`If-None-Match` 会将 `ETag` 发送给服务器，查询该资源 `ETag` 是否变动，有变动的话就将新的资源发送回来。`ETag` 优先级高于 `Last-Modified`。

启发式缓存：如果什么缓存都没设置，浏览器通常会响应头中的 `Date` 减去 `Last-Modified` 值的 10% 作为缓存时间。

### 缓存场景

> 对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略

- 对于某些不需要缓存的资源，可以使用 `Cache-control: no-store` ，表示该资源不需要缓存
- 对于频繁变动的资源，可以使用 `Cache-Control: no-cache` 并配合 `ETag` 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新
- 对于代码文件来说，通常使用 `Cache-Control: max-age=31536000` 并配合协商缓存使用，然后对文件进行指纹处理，一旦文件变动就会立刻下载新的文件


## V8垃圾回收 Garbage Collection 简称 GC

一般垃圾回收分为两种：自动回收和手动回收。JS是采用自动回收策略。

V8 基于一个假说将内存分为新生代和老生代两个区域，新生代存放生存时间短的对象，老生代存放生成时间长的对象。
对于这两个区域，V8 分别使用两个不同的垃圾回收器，以便高效的实施垃圾回收。
- 副垃圾回收器，负责新生代的垃圾回收，通常情况下，大多数小的对象都会被分配到新生区，
- 主垃圾回收器，负责老生代的垃圾回收，除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。

它们都有一套共同的执行流程：
1. 标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
2. 回收非活动对象所占据的内存。就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
3. 内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。

### 副垃圾回收器

新生代中用 Scavenge 算法来处理。把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。

也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

### 主垃圾回收器

由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。

首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

### 引用计数法

对象有没有其他对象引用到它，如果引用数量为0，对象将被垃圾回收机制回收，`es6` 中把引用区分为强引用和弱引用，强引用才会有引用计数叠加。弱引用没有触发引用计数叠加，只要引用计数为 0，弱引用就会自动消失，无需手动回收内存。

### 标记清除法

当变量进入执行环境时标记为“进入环境”，当变量离开执行环境时则标记为“离开环境”，被标记为“进入环境”的变量是不能被回收的，因为它们正在被使用，而标记为“离开环境”的变量则可以被回收

### 内存泄漏场景

- 未清理的定时器
- 未清理的事件监听器
- 将对象存在`map`、`set`后将对象设置为`null`，应该先将`map`中的数据删除再将对象设置为`null`
- 闭包

### 查找内存泄漏

通过谷歌浏览器的开发中工具，找到 `memory` 进行录制，录制完成有一个快照，按照 `Shallow Size` 排序，分析占用内存的对象。


## 跨域 

浏览器有同源策略，同源是指`协议 + 域名 + 端口`三者相同，当其中任意一个不相同时就算不同域，互相请求资源就算跨域。

同源策略限制的内容有：
- `Cookie、LocalStorage、SessionStorage、IndexDB`存储性内容
- 请求发送后，结果被浏览器拦截

但是有一些标签是允许跨域加载资源的: `img、link、script`

跨域处理方法：
- JSONP：利用 `script` 标签没有跨域限制，网页可以得到其他来源动态产生的`JSON`数据。优点是兼容性好，缺点是仅支持`get`方法，不安全可能会受到`XSS`攻击
- CORS：服务端设置`Access-Control-Allow-Origin`，表示哪些域名可以访问资源，通过这种方式处理跨域，复杂请求每次都会发送一次“预检”请求，该请求是`options`方法的，通过该请求来知道服务端是否允许跨域。
1. 简单请求：`GET、POST`,`Content-Type`是`text/plain`或`multipart/form-data`或`application/x-www-form-urlencoded`;
2. 复杂请求：不满足上面的就是复杂请求，比如`PUT`、`DELETE`，或者 `Content-type`为 `application/json`
- Node中间件代理：同源策略是浏览器的标准，服务器向服务器请求则不需要遵守。
1. 代理服务器接收客户端请求转发给服务器。
2. 将服务器响应数据转发给客户端。
- nginx反向代理：直接修改配置即可


## fetch 

`fetch` 是一个原生的请求 `api`
- 优点：
    - 语法简洁，更加语义化
    - 基于 `Promise` 实现，支持 `async/await`
- 问题：
    - 对于网络请求报错如 `400`、`500` 都当做成功的请求，不会 `reject`，只有当请求不能完成时才会被 `reject`
    - 默认不携带 `Cookie`，需要添加配置项 `fetch(url, {credentials: 'include'})`
    - 不支持 `abort`，不支持超时控制，使用 `Promise.reject` 实现的超时控制并不能阻止请求过程继续在后台运行
    - 不能监听请求的进度，无法做到像上传下载进度条这样的效果

## axios

一个基于 `Promise` 用于浏览器和 `nodejs` 的 `HTTP` 客户端，是对原生 `XHR` 的封装，是 `Promise` 的实现版本，特点：
1. 从浏览器中创建 `XML HttpRequest`
2. 支持 `Promise API`
3. 客户端支持防止 `CSRF`
4. 提供了拦截请求和响应
5. 支持取消请求
6. 自动转换 `JSON` 数据

## CSRF、 XSS

### CSRF（Cross-site request forgery）跨站请求伪造

> 利用用户的登录状态发起伪造请求，比如在钓鱼网站加入一个链接，`src`指向我们的接口，就能伪造成是用户发送的请求

防御：
1. 添加 `token` 验证
2. `Referer`验证：只接受本站的请求，如果不是，进行拦截

### XSS（Cross Site Scripting） 跨域脚本攻击

> 攻击者在网站上注入恶意代码，对网页进行篡改，在用户浏览网页时，对用户浏览器进行控制获取用户隐私的一种攻击方式

`XSS` 类型：
1. 反射型：发出请求时，`XSS` 代码出现在 `url` 中，作为输入提交到服务器端，服务端解析后响应，`XSS` 代码随响应内容一起传回浏览器，最后浏览器执行 `XSS` 代码
2. 存储型：提交的 `XSS` 代码会存储在服务器端，可以被其他用户取得并且执行

防御：
1. 输入过滤：对用户输入的内容进行过滤，比如移除用户输入的 `script` 节点
2. 输出转义：对引号，尖括号，斜杠进行转义。 `< 转义 &lt;`
3. 将重要的 `Cookie` 标记为 `httponly`，这样 `js` 脚本不能通过 `document.cookie` 获取 `cookie`
