
### 0.1 + 0.2 != 0.3

计算机无法直接进行十进制的计算，需要先转成二进制，`JS` 采用 `64` 位双精度标准转换成相应的二进制，而 `0.1` 和 `0.2` 转换成二进制都会无限循环，`JS` 采用的标准会将多余的位截掉，所以相加就会有偏差，导致不等于 `0.3`

### 原型链

- `js` 中每个函数都有 `prototype` 属性，这个属性指向的就是原型。
- 通过构造函数创建出来的对象都有一个 `__proto__` 属性，指向了这个构造函数的原型。
- 当对象调用自身不存在的属性或者方法时，就会通过 `__proto__` 去找上层的原型，依次类推，直到找到了属性或者方法，`__proto__` 将原型对象连接起来组成了原型链。

### 继承

- 构造函数继承：在子类中调用父类构造函数 `Parent.call()`，子类实例只能拿到父类的属性, 不能拿到原型上的方法
- 原型链继承：子类原型等于父类实例，`Child.prototype = new Parent()`，子类实例会公用同一个父类原型对象，会互相影响
- 组合继承：同时执行上面两种，缺点是会执行两次 `Parent` 构造函数
- 寄生组合继承：`Child.prototype = Object.create(Parent.prototype)`，`Object.create` 创建了父类原型的副本，与父类原型完全隔离。
    - `Object.create` 方法的实质是新建一个空的构造函数 `F`，然后让 `F.prototype` 属性指向参数对象 `obj`，最后返回 `F` 的实例，从而实现让该实例继承 `obj` 的属性
- 在 `es6` 中通过 `extends` 关键字来实现类继承，原理就是使用了寄生组合来实现的继承

### 闭包

函数执行，会形成一个私有的上下文，保护里面的私有变量不受外界的干扰，当函数执行完，私有变量被外部所引用不能被释放，这些未被释放变量的集合就是闭包。

闭包可以用来缓存数据，封装对象的私有属性私有方法。

扩展：`Vue` 源码中也有一些地方使用到了闭包，比如原型上的 `$watch` 方法，用户调用方法时，会实例化一个 `watcher` 对象，然后返回一个 `unwatchFn` 函数，在这个函数里面，调用了 `watcher` 下的 `teardown` 方法。这样实现的巧妙之处在于，我们不需要关心要调用谁去取消监听，你怎么监听的，他直接给你返回一个取消监听的方法，直接调用这个方法就可以取消监听了。

如果引用闭包的函数是全局变量，闭包就会一直存在直到页面被关闭，如果这个闭包之后不再使用，这会导致内存泄漏。
如果引用闭包的函数是个局部变量，等函数销毁后，在下次 `js` 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 `js` 引擎的垃圾回收器就会回收这块内存。


### 任务队列 Event Loop

- 一开始整个脚本作为一个宏任务执行
- 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
- 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完
- 如果有 `UI` 渲染则执行浏览器UI线程的渲染工作
- 循环直到宏任务和微任务队列都为空
    - `宏任务`：`主线程`、`setTimeout`、`setInterval`、`setImmediate`、`UI rendering`
    - `微任务`：`process.nextTick(nodejs)`、`promise`、`MutationObserver`

### Node 时间环

`Node 11` 中事件循环机制和浏览器保持一致。

`Node`使用 `libuv` 库负责 `node api` 的执行，`libuv` 将事件循环分为 `6` 个阶段反复运行，每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。
- `Timer` 阶段。执行 `setTimeout` `setInterval`
- `I/O callback` 阶段。处理一些上一轮循环中的未执行的 `I/O` 回调
- `idle` 和 `prepare` 阶段。系统内置使用。
- `poll` 轮询阶段。获取新的 `I/O` 事件
- `check` 检测阶段。执行 `setImmediate`
- `close callback` 关闭回调阶段。执行 `socket` 的 `close` 事件回调


### 作用域链

`作用域`：变量和函数的可访问的区域。`js` 的作用域是`词法作用域`，当我们写代码的时候作用域就已经被确定了。

`作用域链`：它是由多个执行上下文的变量对象构成的，每个执行上下文的变量环境中，都有一个引用指向外层的执行上下文，保证当前执行环境能够访问的所有变量和函数是有序的，当我们查找一个变量时，如果当前上下文找不到这个变量，就会通过 `[[Scope]]` 沿着向上查找上级变量，直到找到了这个变量或者到了全局上下文，这个查找的链条就是作用域链。

### this 

- `this` 总是指向函数的直接调用者，也就是 `.` 前面的对象
- 如果是 `new` 出来的对象， `this` 指向该对象
- 可以通过 `bind`、`call`、`apply` 来修改 `this` 的指向

```js
function selfBind(context, ...bindArgs) {
    const fn = this;
    return function F(...args) {
        if (this instanceof F) { // 因为返回了一个函数，我们可以 new F()，所以需要判断
            return new fn(...bindArgs, ...args);
        }
        return fn.apply(context, bindArgs.concat(args));
    }
}
function selfCall(context, ...args) {
    context = context || window;
    const key = Symbol('key');
    context[key] = this;
    const res = context[key](...args);
    delete context[key];
    return res;
}
function selfApply(context, args) {
    context = context || window;
    const key = Symbol('key');
    context[key] = this;
    const res = context[key](args);
    delete context[key];
    return res;
}
```

### new 

- 创建一个空对象，并将 `this` 指向这个对象，继承构造函数的原型
- 执行构造函数，如果构造函数执行后返回的是对象或函数，则返回该对象或函数
- 否则返回创建的对象

```js
function myNew(Ctor, ...args) {
    const obj = Object.create(Ctor.prototype);
    const res = Ctor.apply(obj, args);
    return typeof res === 'object' ? res : obj;
}
Object.create = function(context) {
    function F() {};
    F.prototype = context;
    return new F();  
}
```

### typeof instanceof 

- `typeof`： 对于基本类型，除了 `null` 会显示 `object`，其他都能正确判断，但是对于对象类型，除了 `Function`，其他都显示的是 `object`。
- `instanceof`：判断一个对象的正确的类型，内部通过原型链来判断，但是不能判断基本数据类型
- `Array.isArray`
- `Object.prototype.toString.call(target)`：能正确判断数据的类型


### 模块化

`common.js`：
- `CommonJS` 是一个 `js` 模块化的规范，该规范最初是用在服务器端的 `node` 的，前端的 `webpack` 也是对  `CommonJS` 原生支持的。
- 每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量
- 通过 `require` 方法来同步加载所要依赖的其他模块，然后通过 `exports` 或者 `module.exports` 来导出需要暴露的接口
- `CommonJS` 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以 `CommonJS` 是不适用于浏览器端的。

`amd`：解决从服务端异步加载模块的问题，实现库 `require.js`
- 通过 `define` 来定义一个模块，然后使用 `require` 来加载一个模块。 
- 在使用 `require.js` 的时候，我们必须要提前加载所有的依赖，然后才可以使用，而不是需要使用时再加载。

`cmd`: 按需加载，不是必须在模块开始就加载所有的依赖，实现库阿里玉伯 `sea.js`
- 在需要用到某个模块的时候再 `require`

`es6 Module`模块：
- 使用 `import` 关键字引入模块，通过 `export` 关键字导出模块
- 静态分析：编译时进行加载，在解析阶段就能确定输出的模块的依赖关系，所以 `es6` 模块的 `import` 一般写在引入文件的开头。
- 导出的是整个模块的引用，模块的内部的改变会影响引用的改变

### ES6

#### Set WeakSet Map WeakMap

- `Set`
    - 成员唯一、无序且不重复
    - `[value, value]`，键值与键名是一致的（或者说只有键值，没有键名）
    - 可以遍历，方法有：`add、delete、has`
- `WeakSet`
    - 成员都是对象
    - 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏
    - 不能遍历，方法有 `add、delete、has`
- `Map`
    - 本质上是键值对的集合，类似集合
    - 可以遍历，方法很多可以跟各种数据格式转换
- `WeakMap`
    - 只接受对象作为键名（null除外），不接受其他类型的值作为键名
    - 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的
    - 不能遍历，方法有`get、set、has、delete`


### babel es6 转 es5

babel的转译过程分为三个阶段：`parsing、transforming、generating`，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：

- 将代码字符串解析成 `AST`
- 用 `babel-traverse` 对 `AST` 树进行遍历转译,得到新的 `AST` 树
- 用 `babel-generator` 通过 `AST` 树生成 `ES5` 代码

### V8垃圾回收 Garbage Collection 简称 GC

一般垃圾回收分为两种：自动回收和手动回收。JS是采用自动回收策略。

V8 基于将内存分为新生代和老生代两个区域，新生代存放生存时间短的对象，老生代存放生成时间长的对象。
对于这两个区域，V8 分别使用两个不同的垃圾回收器，以便高效的实施垃圾回收。
- 副垃圾回收器，负责新生代的垃圾回收，通常情况下，大多数小的对象都会被分配到新生区，
- 主垃圾回收器，负责老生代的垃圾回收，除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。

它们都有一套共同的执行流程：
1. 标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
2. 回收非活动对象所占据的内存。就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
3. 内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。

#### 副垃圾回收器

副垃圾回收器主要负责新生区的垃圾回收。把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。

也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

#### 主垃圾回收器

由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。

首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

#### 引用计数法

对象有没有其他对象引用到它，如果引用数量为0，对象将被垃圾回收机制回收，`es6` 中把引用区分为强引用和弱引用，强引用才会有引用计数叠加。弱引用没有触发引用计数叠加，只要引用计数为 0，弱引用就会自动消失，无需手动回收内存。

#### 标记清除法

当变量进入执行环境时标记为“进入环境”，当变量离开执行环境时则标记为“离开环境”，被标记为“进入环境”的变量是不能被回收的，因为它们正在被使用，而标记为“离开环境”的变量则可以被回收


### base64 原理

`base64` 索引表选用了 `A-Z、a-z、0-9、+、/` 这 `64` 个可打印字符，用数值代表字符的索引，`64` 个字符只要 `6` 个 `bit` 位就能表示了，一个普通字节有 `8` 个 `bit` 位， `8` 和 `6` 的最小公倍数是 `24`，也就是说 `3` 个传统字符可以由 `4` 个 `base64` 字符表示，这样就多了 `1/3` 的字节数；要转换成 `base64` 的最小单位是 `3` 个字节，对应 `base64` 的 `4` 个字节，如果不够三个字节，末尾补上 `0` 和 `=`

